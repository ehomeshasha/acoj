#include <bits/stdc++.h>


using namespace std;

/**
小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 下面这个10*10的二维矩阵就是钓鱼岛的航拍地图。图中数字表示海拔，0表示海洋，1~9都表示陆地。
 小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落所在岛的面积（即有多少个格子）。
 注意此处我们把与小哼降落点上下左右相链接的陆地均视为同一岛屿。
输入格式:
一行4个整数，前两个整数表示n行m列，后两个整数表示降落的坐标x行y列
接下来n行，每行m列，整数之间用空格隔开表示地图。
输出格式:
一个整数表示岛屿的面积
限制:
n<=100
m<=100
样例 1 :
输入:
10 10 6 8
1 2 1 0 0 0 0 0 2 3
3 0 2 0 1 2 1 0 1 2
4 0 1 0 1 2 3 2 0 1
3 2 0 0 0 1 2 4 0 0
0 0 0 0 0 0 1 5 3 0
0 1 2 1 0 1 5 4 3 0
0 1 2 3 1 3 6 2 1 0
0 0 3 4 8 9 7 5 0 0
0 0 0 3 7 8 6 0 1 2
0 0 0 0 0 0 0 0 1 0
输出:
38
 */

// dfs解法
int N,M,sx,sy,grid[105][105]={0},cnt=1;
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};

void dfs(int x, int y)
{
    for (int i=0;i<4;i++) {
        if (grid[x+dx[i]][y+dy[i]]!=0) {
            cnt++;
            grid[x+dx[i]][y+dy[i]]=0;
            dfs(x+dx[i],y+dy[i]);
        }
    }
}

int main()
{
    cin >> N >> M >> sx >> sy;
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=M;j++) {
            cin >> grid[i][j];
        }
    }

//    // 打印地图
//    for (int i=1;i<=N;i++) {
//        for (int j=1;j<=M;j++) {
//            printf("%d ",grid[i][j]);
//        }
//        printf("\n");
//    }
    if (grid[sx][sy]==0) { // 降落的地方不是岛屿
        cout << 0;
        return 0;
    }
    grid[sx][sy]=0;
    dfs(sx,sy);
    cout << cnt;
    return 0;
}
