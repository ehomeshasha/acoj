#include <bits/stdc++.h>


using namespace std;

/**
生命游戏(Game of life)由英国数学家John Conway在1970年发明。事实上，它是一个“零人游戏”，也没有胜负之分，而是相当于一个确定性自动机。
游戏在N×M的细胞组成的矩阵里进行，每个细胞每个时刻的状态可能是“存活”或者“休眠”两种,细胞矩阵的状态会按以下规则进行演化：
一个存活状态的细胞，在某一秒，若周围的存活状态的细胞数目不足两个，则下一秒将由于孤独而进入休眠状态。 当前存活 0,1 下一秒休眠
一个存活状态的细胞，在某一秒，若周围的存活状态的细胞数目超过三个，则下一秒将由于过度拥挤而进入休眠状态。  当前存活 4,5,6,7,8 下一秒休眠
一个存活状态的细胞，在某一秒，若周围的存活状态的细胞数目为两或三个，则下一秒将继续保持存活状态。  当前存活 2,3  下一秒继续存活
一个休眠状态的细胞，在某一秒，若周围的存活状态的细胞数目为正好三个，则认为是比较适合生存的状态，将于下一秒进入存活状态。  当前休眠 3 下一秒存活
这里“周围”的范围包括一个细胞的上、下、左、右、左上、左下、右上、右下的细胞，如果存在的话。
现在，给定一个初始状态（即第1秒时的状态），请按照规则计算第T秒时的状态。
输入格式:
第一行，三个空格隔开的整数：M、N和T。
第二行开始的N行，每行M个字符，“0”或“1”分别代表休眠状态与存活状态的细胞。
输出格式:
输出N行，每行M个“0”或“1”，表示第T秒时的状态。
限制:
1 <= N, M <= 100
1 <= T <= 64
样例 1 :
输入:
5 5 1
00000
01100
01010
00100
00000
输出:
00000
01100
01010
00100
00000
 */


// 当前存活 0,1 下一秒休眠
// 当前存活 4,5,6,7,8 下一秒休眠
// 当前存活 2,3  下一秒继续存活
// 当前休眠 3 下一秒存活
int N,M,T,grid[105][105],tmp[105][105]; // 表格中0代表边界，0代表休眠，1代表存活
int dxy[8][2]={{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{1,-1},{-1,1},{1,1}};
int jisuan(int x, int y)
{
    int cnt=0;
    for (int i=0;i<8;i++) {
        if (grid[x+dxy[i][0]][y+dxy[i][1]]==1) cnt++;
    }
    if (grid[x][y]==1) {
        if (cnt<2||cnt>3) return 0; // 过于孤独和拥挤
        else return 1; // 继续存活
    } else {
        if (cnt==3) return 1; // 休眠到存活
        else return 0; // 继续休眠
    }
}

int main()
{
    cin >> M >> N >> T;
    char t[4],c;
    gets(t);
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=M;j++) {
            c=getchar();
            grid[i][j]=c-'0';
        }
        gets(t);
    }
    for (int i=1;i<=T-1;i++) {
        for (int j=1;j<=N;j++) {
            for (int k=1;k<=M;k++) {
                // 不能就地变化，要先存储临时表
                tmp[j][k]=jisuan(j,k);
            }
        }
        // 填回表格
        for (int j=1;j<=N;j++) {
            for (int k=1;k<=M;k++) {
                grid[j][k]=tmp[j][k];
            }
        }
    }
    // 打印表格
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=M;j++) {
            printf("%d",grid[i][j]);
        }
        printf("\n");
    }
    return 0;
}
