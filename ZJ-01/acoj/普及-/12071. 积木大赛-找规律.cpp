#include <iostream>
#include <algorithm>

using namespace std;

/**
春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为n的大厦,大厦可以看成由n块宽度为1的积木组成,第i块积木的最终高度需要是hi。

在搭建开始之前,没有任何积木(可以看成n块高度为 0 的积木)。接下来每次操作, 小朋友们可以选择一段连续区间 [ L , R ],然后将第L块到第R块之间(含第L 块和第R块)所有积木的高度分别增加1。

小M是个聪明的小朋友,她很快想出了建造大厦的最佳策略,使得建造所需的操作次数最少。但她不是一个勤于动手的孩子,所以想请你帮忙实现这个策略,并求出最少的操作次 数。

输入格式:

输入包含两行,第一行包含一个整数n ,表示大厦的宽度。 第二行包含 n 个整数,第 i 个整数为hi。
输出格式:

仅一行,即建造所需的最少操作数。
限制:

对于 30%的数据,有1 ≤ n ≤ 10;
对于 70%的数据,有1 ≤ n ≤ 1000;
对于 100%的数据,有1 ≤ n ≤ 100000,0 ≤ hi ≤ 10000。
样例 1 :

输入:
5
2 3 4 1 2
输出:
5
说明:
其中一种可行的最佳方案,依次选择
[1,5] [1,3] [2,3] [3,3] [5,5]
 */


int main()
{
    //这个题直接找规律就行了，可以发现
    //h[i]<h[i+1]，即左边的一组比右边的矮，当高度满足左面时，右边的还差一些，那么ans加上两堆的高度差；
    //h[i]>=h[i+1]，即左边的一组比右边的高，当高度满足左面时，右边的也一定满足了，所以不需要增加ans。
    //所以最终结果就是a[0]+ans
    int n;
    cin >> n ;
    int* a = new int[n];
    for(int i=0;i<n;i++)
        cin >> a[i] ;

    int s=a[0];
    for(int i=1;i<n;i++)
        if(a[i]>a[i-1])s+=a[i]-a[i-1];

    cout << s << endl ;
    return 0;
}


