#include <bits/stdc++.h>


using namespace std;

/**
牛奶生意正红红火火！林克的牛奶加工厂内有N个加工站，编号为1…N（1≤N≤100），以及N−1条通道，每条连接某两个加工站。
（通道建设很昂贵，所以林克选择使用了最小数量的通道，使得从每个加工站出发都可以到达所有其他加工站）。
为了创新和提升效率，林克在每条通道上安装了传送带。不幸的是，当他意识到传送带是单向的已经太晚了，现在每条通道只能沿着一个方向通行了！
所以现在的情况不再是从每个加工站出发都能够到达其他加工站了。
然而，林克认为事情可能还不算完全失败，只要至少还存在一个加工站i满足从其他每个加工站出发都可以到达加工站i。
 注意从其他任意一个加工站j前往加工站i可能会经过i和j之间的一些中间站点。请帮助林克求出是否存在这样的加工站i。
输入格式:
输入的第一行包含一个整数N，为加工站的数量。以下N−1行每行包含两个空格分隔的整数ai和bi，满足1≤ai,bi≤N以及ai≠bi。
 这表示有一条从加工站ai向加工站bi移动的传送带，仅允许沿从ai到bi的方向移动。
输出格式:
如果存在加工站i满足可以从任意其他加工站出发都可以到达加工站i，输出最小的满足条件的i。否则，输出−1。
样例 1 :
输入:
3
1 2
3 2
输出:
2
 */
int cnt=0;
vector<int> tree[101];

void bfs(int x)
{
    for(int i=0;i<tree[x].size();i++) {
        cnt++;
        bfs(tree[x][i]);
    }
}

int main()
{
    int N,ai,bi;
    cin >> N;
    for (int i=0;i<N-1;i++) {
        cin >> ai >> bi;
        tree[bi].push_back(ai); // 单向, 且反向， 反向假设给的是bi到ai，那么所有能到达i的其实就是所有能从i出发从bi到ai的
    }
    // bfs
    // 从小到大遍历所有的节点， 然后从该节点出发再进行bfs遍历， 找到一个新节点就+1
    for (int i=1;i<=N;i++) {
        // 针对每个i找到可以到的所有工作站 bfs
        cnt=0;
        bfs(i);
        // 结束后判断节点数是否等于N，等于则break， 输出i
        if (cnt==N-1) {
            printf("%d", i);
            return 0;
        }
    }
    // 遍历完还没有i，输出-1
    printf("-1");
    return 0;
}
