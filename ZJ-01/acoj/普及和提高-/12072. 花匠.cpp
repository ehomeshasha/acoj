#include <bits/stdc++.h>


using namespace std;

/**
花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。
 栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。
具体而言，栋栋的花的高度可以看成一列整数h1, h2, … , hn。
 设当一部分花被移走后，剩下的花的高度依次为g1, g2, … , gm，则栋栋希望下面两个条件中至少有一个满足：
条件 A：对于所有的1 <= i < n / 2，g_2i > g_2i−1，且g_2i > g_2i+1；
条件 B：对于所有的1 <= i < n / 2，g_2i < g2i−1，且g_2i < g_2i+1。
此处2i及2i-1，2i+1都为下标。
注意上面两个条件在m = 1时同时满足，当m > 1时最多有一个能满足。
请问，栋栋最多能将多少株花留在原地。
输入格式:
输入的第一行包含一个整数 n，表示开始时花的株数。
第二行包含 n 个整数，依次为h1, h2,… , hn，表示每株花的高度。
输出格式:
输出一行，包含一个整数 m，表示最多能留在原地的花的株数。
提示:
对于 20%的数据，n ≤ 10；
对于 30%的数据，n ≤ 25；
对于 70%的数据，n ≤ 1000，0 ≤ hi ≤ 1000；
对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤ hi ≤ 1,000,000，所有的h_i随机生成，所有随机数服从某区间内的均匀分布。
样例 1 :
输入:
5
5 3 2 1 2
输出:
3

 */
int N,flower[100005],rm_cnt=0,fx=0; // fx代表修剪方向，0为初始值，1代表往上，2代表往下

int main()
{
    // 思路， 从左往右递推， 从1~n， 用贪心算法， 满足条件就不拿
    cin >> N;
    for (int i=1;i<=N;i++) {
        cin >> flower[i];
    }
    if (N<=2) {
        cout << N;
        return 0;
    }
    // 向上条件
    for (int i=1;i<=N-1;i++) {
        if (flower[i]==flower[i+1]||fx==1&&flower[i]<flower[i+1]||fx==2&&flower[i]>flower[i+1]) {
            flower[i]=-1;
            rm_cnt++;
        } else {
            if (flower[i]<flower[i+1]) fx=1;
            else if (flower[i]>flower[i+1]) fx=2;
        }
    }
    cout << N-rm_cnt;
    return 0;
}
