#include <bits/stdc++.h>


using namespace std;

/**
淘淘要在下个月交给老师n篇作文，作文的内容可以从m个题目中选择。
由于题目数有限，淘淘不得不重复选择一些题目。完成不同题目的作文所花的时间不同。
具体地说，对于某个题目i，若淘淘计划一共写x篇作文，则完成该题目的作文总共需要花费Ai*x^Bi个单位时间（系数Ai和指数Bi均为正整数）。
给定与每一个题目相对应的Ai和Bi的值，请帮助淘淘计算出如何选择作文的题目使得他可以花费最少的时间完成这n篇作文。
输入格式:
第一行有两个用空格隔开的正整数n和m，分别代表需要完成的作文数和可供选择的题目数。
以下m行每行有两个用空格隔开的正整数。其中，第i行的两个数分别代表与第i个题目相对应的时间系数Ai和指数Bi。
对于30%的数据，n<=10,m<=5；
对于100%的数据，n<=200，m<=20，Ai<=100，Bi<=5。
输出格式:
输出完成n篇作文所需要耗费的最少时间。
样例 1 :
输入:
10 3
2 1
1 2
2 1
输出:
19
 */
int N,M,total=0,tongji[25]={0}; // 统计数组，统计出现的次数
long long tbl[25][205]={0},Ai,Bi;
int main()
{
    // 打表， 得出每个题目在数量x时候的时间
    // 每次选一篇作文， 选取在数量增加最小的那个， 即对于每个选题，求x+1本时间-x本时间差值最小的那个
    // 一直选取到结束
    cin >> N >> M;
    for (int i=1;i<=M;i++) {
        cin >> Ai >> Bi;
        for (int j=1;j<=200;j++) {
            tbl[i][j]=Ai*pow(j,Bi);
        }
    }
    // 打印表
//    for (int i=1;i<=M;i++) {
//        for (int j=1;j<=200;j++) {
//            printf("%d ",tbl[i][j]);
//        }
//        printf("\n");
//    }
    // 边界条件测试,最大可能值为100*200^5=320000000000，超出20亿，因此要用long long 打表
    // cout << pow(2, 5) << " " << pow(5, 5) << " " << pow(10,5);

    // 开始动工
    for (int i=1;i<=N;i++) { // 选N篇作文
        int min_time1=0x3f3f3f3f,min_j;
        for (int j=1;j<=M;j++) { // 对于M个题目
            int cha=tbl[j][tongji[j]+1]-tbl[j][tongji[j]]; // 增加的时间就是选取当前题目再加一篇和当前篇数的差值
            if (min_time1>cha) {
                min_time1=cha; // 得出最小花费时间min_time1
                min_j=j; // 得出哪个题目
            }
        }
        tongji[min_j]++; // 加入计数数组，保存该题目当前篇数
        total+=min_time1;
    }
    cout << total;
    return 0;
}
