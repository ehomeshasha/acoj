#include <bits/stdc++.h>


using namespace std;

/**
Farmer John 想让她的奶牛准备郡级跳跃比赛，贝茜和她的伙伴们正在练习跨栏。
 她们很累，所以她们想消耗最少的能量来跨栏。
 显然，对于一头奶牛跳过几个矮栏是很容易的，但是高栏却很难。于是，奶牛们总是关心路径上最高的栏的高度。
 奶牛的训练场中有 N (1 ≤ N ≤ 300) 个站台，分别标记为1..N。所有站台之间有M (1 ≤ M ≤ 25,000)条单向路径，
 第i条路经是从站台Si开始，到站台Ei，其中最高的栏的高度为Hi (1 ≤ Hi ≤ 1,000,000)。
 无论如何跑，奶牛们都要跨栏。
 奶牛们有 T (1 ≤ T ≤ 40,000) 个训练任务要完成。
 第 i 个任务包含两个数字 Ai 和 Bi (1 ≤ Ai ≤ N; 1 ≤ Bi ≤ N)，表示奶牛必须从站台Ai跑到站台Bi，可以路过别的站台。
 奶牛们想找一条路径从站台Ai到站台Bi，使路径上最高的栏的高度最小。 你的任务就是写一个程序，计算出路径上最高的栏的高度的最小值。
输入格式:
第一行1：两个整数 N, M, T 行
接下来M行：每行包含三个整数 Si , Ei , Hi
接下来T 行：每行包含两个整数，表示任务i的起始站台和目标站台: Ai , Bi
输出格式:
行 1..T: 行 i 为一个整数，表示任务i路径上最高的栏的高度的最小值。如果无法到达，输出 -1。
样例 1 :
输入:
5 6 3
1 2 12
3 2 8
1 3 5
2 5 3
3 4 4
2 4 8
3 4
1 2
5 1
输出:
4
8
-1
 */

int N,M,T,tbl[305][305];

int main()
{
    // 输入处理
    // 求全排列 N个里面取2个 tbl[305][305]打表
    // floyd算法， 不停打表更新里面的值，从P1打到PN打N次
    // 对T来进行输出
    // 初始化表格
    for (int i=0;i<305;i++) {
        for (int j=0;j<305;j++) {
            if (i==j) tbl[i][j]=0;
            else tbl[i][j]=0x3f3f3f3f;
        }
    }
    scanf("%d %d %d\n",&N,&M,&T);
    int t1,t2,t3;
    for (int i=1;i<=M;i++) {
        scanf("%d %d %d\n",&t1,&t2,&t3);
        tbl[t1][t2]=t3;
    } // P0表完成打表

    for (int i=1;i<=N;i++) { // 从P1开始逐个打表
        for (int j=1;j<=N;j++) {
            for (int k=1;k<=N;k++) {
                if (j==k||j==i||k==i) continue; // 对角线和当前中转i不打表
                // 中转后求最优解 2->3 2->1 1->3
                tbl[j][k]=min(max(tbl[j][i],tbl[i][k]), tbl[j][k]); // 两条中间路径取最大值，然后和当前值比求最小值，填回当前值
            }
        }
    }

    int t4,t5;
    // 打表完成，求输出
    for (int i=0;i<T;i++) {
        scanf("%d %d\n",&t4,&t5);
        if (tbl[t4][t5]>1000000) printf("-1");
        else printf("%d", tbl[t4][t5]);
        printf("\n");
    }return 0;
}
