#include <bits/stdc++.h>


using namespace std;

/**
一块N x N（1<=N<=10）正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：
1：转90度：图案按顺时针转90度。
2：转180度：图案按顺时针转180度。
3：转270度：图案按顺时针转270度。
4：反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。
5：组合：图案在水平方向翻转，然后再按照1到3之间的一种再次转换。
6：不改变：原图案不改变。
7：无效转换：无法用以上方法得到新图案。
如果有多种可用的转换方法，请选择序号最小的那个。
只使用1~7中的一个步骤来完成这次转换。
输入格式:
第一行： 单独的一个整数N。
第二行到第N+1行： N行每行N个字符（不是“@”就是“-”）；这是转换前的正方形。
第N+2行到第2*N+1行： N行每行N个字符（不是“@”就是“-”）；这是转换后的正方形。
输出格式:
单独的一行包括1到7之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。
样例 1 :
输入:
1) 转90度
1,1 -> 1,3
1,2 -> 2,3
1,3 -> 3,3
2,1 -> 1,2
2,2 -> 2,2
2,3 -> 3,2
3,1 -> 1,1
3,2 -> 2,1
3,3 -> 3,1
sg[x][j][N-i+1]=sg[0][i][j]
2) 转180度
1,1 -> 3,3
1,2 -> 3,2
1,3 -> 3,1
2,1 -> 2,3
2,2 -> 2,2
2,3 -> 2,1
3,1 -> 1,3
3,2 -> 1,2
3,3 -> 1,1
sg[x][N-i+1][N-j+1]=sg[0][i][j]
3) 转270度
1,1 -> 3,1
1,2 -> 2,1
1,3 -> 1,1
2,1 -> 3,2
2,2 -> 2,2
2,3 -> 1,2
3,1 -> 3,3
3,2 -> 2,3
3,3 -> 1,3
sg[x][N-j+1][i]=sg[0][i][j]
4) 反射
4
@@@@
@@@@
-@@@
@@@@
@@@@
@@@@
@@@-
@@@@

1,1 -> 1,3
1,2 -> 1,2
1,3 -> 1,1
2,1 -> 2,3
2,2 -> 2,2
2,3 -> 2,1
3,1 -> 3,3
3,2 -> 3,2
3,3 -> 3,1
sg[x][i][N-j+1]=sg[0][i][j]

5) 组合
反射+旋转
6) 不改变
7) 无效转换
即左右上下对称

3
@-@
---
@@-
@-@
@--
--@
输出:
1
 */
int N;
char sg[11][11][11],eg[11][11];
char tc[4];

bool equal(char g1[11][11], char g2[11][11])
{
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=N;j++) {
            if (g1[i][j]!=g2[i][j]) return false;
        }
    }
    return true;
}
void mprint(char g[11][11])
{
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=N;j++) {
            printf("%c ",g[i][j]);
        }
        printf("\n");
    }
}

int main()
{
    scanf("%d\n",&N);
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=N;j++) {
            sg[0][i][j]=getchar();
        }
        gets(tc);
    }
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=N;j++) {
            eg[i][j]=getchar();
        }
        gets(tc);
    }
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=N;j++) {
            // 1.转90度
            sg[1][j][N-i+1]=sg[0][i][j];
            // 2.转180度
            sg[2][N-i+1][N-j+1]=sg[0][i][j];
            // 3.转270度
            sg[3][N-j+1][i]=sg[0][i][j];
            // 4.反射
            sg[4][i][N-j+1]=sg[0][i][j];
            // 5.组合1
            sg[5][i][N-j+1]=sg[0][i][j]; // 先反射
            // 5.组合2
            sg[7][i][N-j+1]=sg[0][i][j]; // 先反射
            // 5.组合3
            sg[9][i][N-j+1]=sg[0][i][j]; // 先反射
            // 6.不变
            // 7.无效转换
        }
    }
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=N;j++) {
            sg[6][j][N-i+1]=sg[5][i][j]; // 转90度
            sg[8][N-i+1][N-j+1]=sg[7][i][j]; // 转180度
            sg[10][N-j+1][i]=sg[9][i][j]; // 转270度
        }
    }
//    mprint(sg[0]);
//    printf("\n");
//    mprint(sg[6]);
//    printf("\n");
//    mprint(eg);
    int ans;
    if (equal(sg[1],eg)) ans=1;
    else if (equal(sg[2],eg)) ans=2;
    else if (equal(sg[3],eg)) ans=3;
    else if (equal(sg[4],eg)) ans=4;
    else if (equal(sg[6],eg)||equal(sg[8],eg)||equal(sg[10],eg)) ans=5;
    else if (equal(sg[0],eg)) ans=6;
    else ans=7;
    cout << ans;
    return 0;
}
