#include <bits/stdc++.h>


using namespace std;

/**
有一个有向图，有n个顶点m条边，请使用邻接矩阵存储这个图，
并输出这个图的邻接矩阵。
如果如果两个点之间有多条边则邻接矩阵中只保存最短的边。如果两点之间没有边则输出9个9 999999999
输入格式:
输入文件第一行包含一个正整数 N 和 M；
接下来 M 行， 每行三个正整数 U、 V、 W， 表示该条道路为从 U 到 V 的， 且通过这条道路
需要 W 的时间。满足 1≤U， V≤N,1≤W≤10000, 输入保证任意两点都能互相到达。
输出格式:
一个n*n的矩阵，。矩阵的i行j列表示第i号城市和j号城市之间直接通路的时间。
限制:
对于 30%的数据，满足 1≤N≤200。
对于 100%的数据，满足 1≤N≤1000,1≤M≤100000。
样例 1 :
输入:
5 10
2 3 5
1 5 5
3 5 6
1 2 8
1 3 8
5 3 4
4 1 8
4 5 3
3 5 -1
5 4 2
输出:
0 8 8 999999999 5
999999999 0 5 999999999 999999999
999999999 999999999 0 999999999 -1
8 999999999 999999999 0 3
999999999 999999999 4 2 0
 */

int main()
{
    int a[1005][1005]={0},N,M,U,V,W;
    cin >> N >> M;
    for (int i=1;i<=M;i++) {
        cin >> U >> V >> W;
        if (a[U][V]==0||a[U][V]>W) a[U][V]=W;
    }
    for (int i=1;i<=N;i++) {
        for (int j=1;j<=N;j++) {
            if (i==j) printf("%d ",0);
            else if (a[i][j]==0) printf("%d ",999999999);
            else printf("%d ",a[i][j]);
        }
        printf("\n");
    }

    return 0;
}
