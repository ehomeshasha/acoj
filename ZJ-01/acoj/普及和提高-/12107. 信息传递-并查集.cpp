#include <iostream>
#include <cstdio>
using namespace std;
const int N = 200010;
int n, fa[N], ans = 0x3f3f3f3f;
int get (int x, int &cnt) { //cnt记录环的长度
    cnt ++;
    if (fa[x]==x) return x;
    else return get(fa[x],cnt);
}

/**
有 n 个同学（编号为 1 到 n）正在玩一个信息传递的游戏。
 在游戏里每人都有一个固定的信息传递对象，其中，编号为 i 的同学的信息传递对象是编号为 Ti 的同学。
 游戏开始时，每人都只知道自己的生日。
 之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象
 （注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。
 当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？
输入格式:
第 1 行包含 1 个正整数 n ，表示 n 个人。
第 2 行包含 n 个用空格隔开的正整数T1,T2,… ,Tn，其中第Ti个整数表示编号为 i 的同学的信息传递对象是编号为 Ti 的同学，Ti ≤n 且Ti ≠i。
数据保证游戏一定会结束。
输出格式:
输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。
限制:
n<=200000
样例 1 :
输入:
5
2 4 2 3 1
输出:
3
说明:
游戏的流程如图所示。当进行完第 3 轮游戏后，4 号玩家会听到 2 号玩家告诉他自己的生日，所以答案为 3。当然，第 3 轮游戏后，2 号玩家、3 号玩家都能从自己的消息 来源得知自己的生日，同样符合游戏结束的条件。
样例 2 :
输入:
11
8 7 5 8 8 2 6 3 2 9 10
输出:
3
 */
int main () {
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        fa[i]=i;
    for (int i=1;i<=n;i++) {
        int cnt=0,t;
        scanf("%d",&t);
        if (get(t,cnt) == i) ans=min(ans,cnt); //维护最小的环
        else fa[i]=t;
    }
    printf("%d",ans);
    return 0;
}