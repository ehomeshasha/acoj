#include <bits/stdc++.h>


using namespace std;

/**
13号又是一个星期五。13号在星期五比在其他日子少吗?为了回答这个问题,写一个程序，要求计算每个月的十三号落在周一到周日的次数。
给出N年的一个周期，要求计算1900年1月1日至1900+N-1年12月31日中十三号落在周一到周日的次数，N为正整数且不大于400.
注意，开始今年是1900年，不是1990年.
这里有一些你要知道的:
1、1900年1月1日是星期一.
2、4,6,11和9月有30天.其他月份除了2月都有31天.闰年2月有29天,平年2月有28天.
3、年份可以被4整除的为闰年(1992=4*498 所以 1992年是闰年,但是1990年不是闰年).
4、以上规则不适合于世纪年。可以被400整除的世纪年为闰年,否则为平年。所以,1700,1800,1900和2100年是平年,而2000年是闰年.
请不要调用现成的函数.
请不要预先算好数据(打表).

输入格式:

一个正整数n.
输出格式:

七个在一行且相分开的整数,它们代表13日是星期六,星期日,星期一...星期五的次数.
样例 1 :

输入:
20
输出:
36 33 34 33 35 35 34
 */

int main()
{
    int count[8]={0},N,weekday=1,month=1,monthday=1,year=1900,n=0; // weekday 1-6代表周1到周六，0代表周日
    int m12[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    int runnian=0;
    cin >> N;
    // 1900年1月1日至1919年12月31日
    for (int day=1;;day++) {
//        printf("%d-%d-%d %d\n", year,month,monthday, weekday);
        // 判断当前是每个月的第几号
        if (monthday==13) { // 是每个月13号
            count[weekday]++;
        }
        if (monthday!=m12[month]) { // 如果不是每个月最后一天
            monthday++;
        } else { // 如果到每个月的最后一天
            month=month%12+1;
            monthday=1;
            if (month==1) { // 如果是这个月最后一天且该月为12月，需要跨年
                // 跨年之后的逻辑
                n++;
                if (n==N) { // 数完所有年，break跳出结束
                    break;
                }
                // 重置新的一年
                year++;
                // 重置新的一年2月份的天数
                if (year%100==0) { // 如果是世纪年
                    if (year%400==0) runnian=1;
                    else runnian=0;
                } else if (year%4==0) { // 非世纪年能被4整除为闰年
                    runnian=1;
                } else {
                    runnian=0;
                }
                m12[2]=28+runnian;
            }
        }


        weekday=weekday%7+1;
    }
    printf("%d %d %d %d %d %d %d", count[6],count[7],count[1],count[2],count[3],count[4],count[5]);
    return 0;
}
