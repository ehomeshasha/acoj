#include <bits/stdc++.h>


using namespace std;

/**
n 个小伙伴(编号从 0 到 n-1)围坐一圈玩游戏。
 按照顺时针方向给 n 个位置编号,从0 到 n-1。最初,第 0 号小伙伴在第 0 号位置,第 1 号小伙伴在第 1 号位置,......,依此类 推。
 游戏规则如下:每一轮第 0 号位置上的小伙伴顺时针走到第 m 号位置,第 1 号位置小 伙伴走到第 m+1 号位置,......,依此类推,
 第n − m号位置上的小伙伴走到第 0 号位置,第 n-m+1 号位置上的小伙伴走到第 1 号位置,......,第 n-1 号位置上的小伙伴顺时针走到第 m-1 号位置。
 现在,一共进行了 10的k次方 轮,请问 x 号小伙伴最后走到了第几号位置。
输入格式:
输入共 1 行,包含 4 个整数 n、m、k、x,每两个整数之间用一个空格隔开。
输出格式:
输出共 1 行,包含 1 个整数,表示 10k 轮后 x 号小伙伴所在的位置编号。
限制:
对于 30%的数据,0 < k < 7;
对于 80%的数据,0 < k < 10^7;
对于 100%的数据,1 < n < 1,000,000,0 < m < n,1 ≤ x ≤ n,0 < k < 10^9。
样例 1 :
输入:
10 3 4 5
输出:
5
 */
long long ksm(long long a, long long b, long long N)
{
    long long res=1;
    while(b!=0) {
        if (b&1) {
            res=(res*a)%N;
        }
        a=(a*a)%N;
        b=b/2;
    }
    return res;
}


int main()
{
    long long N,M,K,X;
    cin >> N >> M >> K >> X;
    // 1轮  (x+M)%N
    // 2轮 ((x+M)%N+M)%N
    // 依次类推
    // 10^9太多循环次数了， 快速幂+取模简化
    long long loop_cnt=ksm(10,K, N); // 快速幂简化
    long long t=(M*loop_cnt)%N;
    cout << (X+t)%N;
    return 0;
}
