#include <iostream>

using namespace std;
int main()
{
    /**
     * 给对于一个五位数 a1a2a3a4a5，可将其拆分为三个子数： sub1=a1a2a3 sub2=a2a3a4 sub3=a3a4a5
     * 例如，五位数 20207 可以拆分成: sub1=202 sub2=020(=20) sub3=207
     * 现在给定一个正整数 K,要求你编程求出 10000 到 30000 之间所有满 足下述条件的五位数，条件是这些五位数的三个子数 sub1,sub2,sub3 都可以被 K 整除
     *
     * 分析过程
     * 10000可以拆成100,0,0，0可以被任何数整除，判断100是否可以被整数K整除
     * 同样的数还有10000，20000，30000 3个数
     *
     * 另外三个子数取值范围，去掉前导0后为 [0, 999]
     *
     *
     * 思路
     * 1. 遍历五位数，对数字进行分离，都是正数 10000到30000， 需要遍历20001次
     * 2. 对每个数进行拆分成3个子数， 运用数字分离法， 个位= i % 10 / 1, 十位= i % 100 / 10，百位= i % 1000 / 100, 千位= i % 10000 / 1000, 万位= i % 100000 / 10000
     * 3. 直接对3个数取模都为0的输出
     * 4. 注意不要漏掉完全无解的情况， 需要输出No，不然只能爆70分
     *
     */
    int K;
    cin >> K;
    int a[5]; // a里面按照 个十百千万 存储了5个数位
    bool exist = false;
    for (int i = 10000; i <= 30000; i++) {
        int k = 0;
        for (int j = 1;; j *= 10) {
            if (j > i) {
                break;
            }
            int number = i % (j * 10) / j;
            a[k] = number;
            k++;
        }
        // 分离出3个子数, 利用数位乘以进制正好可以消掉前导0，打断点调试一下
        int sub1 = a[4] * 100 + a[3] * 10 + a[2];
        int sub2 = a[3] * 100 + a[2] * 10 + a[1];
        int sub3 = a[2] * 100 + a[1] * 10 + a[0];
        if (sub1 % K == 0 && sub2 % K == 0 && sub3 % K == 0) {
            exist = true;
            cout << i << endl;
        }
    }
    if (!exist) {
        cout << "No" << endl;
    }

    return 0;
}
