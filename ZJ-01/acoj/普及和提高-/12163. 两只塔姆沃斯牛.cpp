#include <bits/stdc++.h>


using namespace std;

/**
两只牛逃跑到了森林里。农夫John开始用他的专家技术追捕这两头牛。你的任务是模拟他们的行为(牛和John)。
追击在10x10的平面网格内进行。一个格子可以是：空地，一个障碍物, 两头牛(它们总在一起), 或者农民John.

‘.’ 空地
‘*’ 障碍物
‘C’ 两头牛
‘F’ 农民John

两头牛和农民John可以在同一个格子内(当他们相遇时)，但是他们都不能进入有障碍的格子。
这里有一个地图的例子：

*...*.....
......*...
...*...*..
..........
...*.F....
*.....*...
...*......
..C......*
...*.*....
.*.*......
牛在地图里以固定的方式游荡。每分钟，它们可以向前移动或是转弯。如果前方无障碍(地图边沿也是障碍)，它们会按照原来的方向前进一步。否则它们会用这一分钟顺时针转90度。 同时，它们不会离开地图。
农民John深知牛的移动方法，他也这么移动。
每次(每分钟)农民John和两头牛的移动是同时的。如果他们在移动的时候穿过对方，但是没有在同一格相遇，我们不认为他们相遇了。当他们在某分钟末在某格子相遇，那么追捕结束。
读入十行表示农夫John,两头牛和所有障碍的位置的地图。每行都只包含10个字符，表示的含义和上面所说的相同，你可以确定地图中只有一个F和一个C.F和C一开始不会处于同一个格子中。
计算农夫John需要多少分钟来抓住他的牛，假设牛和农夫John一开始的行动方向都是正北（即上）。如果John和牛永远不会相遇，输出0。

输入格式:

第1-10行:
每行10个字符，表示如上文描述的地图
输出格式:

输出一个数字，表示John需要多少时间才能抓住牛们。如果John无法抓住牛，则输出0。
样例 1 :

输入:
*...*.....
......*...
...*...*..
..........
...*.F....
*.....*...
...*......
..C......*
...*.*....
.*.*......
输出:
49

 */
int FX,FY,CX,CY,grid[12][12],ans=0;
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1}; // 上右下左
char c,tc[4];

void dfs(int d1, int d2, int step)
{
    if (step>100000) {
        return;
    }
    if (FX==CX&&FY==CY) {
        ans=step;
        return;
    }
    if (grid[FX+dx[d1]][FY+dy[d1]]==1) { // 继续走
        FX+=dx[d1],FY+=dy[d1];
    } else {
        d1=(d1+1)%4; // 转90度
    }
    if (grid[CX+dx[d2]][CY+dy[d2]]==1) { // 继续走
        CX+=dx[d2],CY+=dy[d2];
    } else {
        d2=(d2+1)%4; // 转90度
    }
    dfs(d1,d2,step+1);
}

int main()
{
    for (int i=1;i<=10;i++) {
        for (int j=1;j<=10;j++) {
            c=getchar();
            if (c=='.') grid[i][j]=1;
            else if (c=='C') CX=i,CY=j,grid[i][j]=1;
            else if (c=='F') FX=i,FY=j,grid[i][j]=1;
        }
        gets(tc);
    }
    // 打印地图
//    for (int i=0;i<12;i++) {
//        for (int j=0;j<12;j++) {
//            printf("%d ",grid[i][j]);
//        }
//        printf("\n");
//    }
    // dfs，不记录走过的，可以反复走
    dfs(0,0,0);
    cout << ans;
    return 0;
}
