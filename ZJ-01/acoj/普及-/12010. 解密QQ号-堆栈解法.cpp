#include <iostream>

using namespace std;

/**
新学期开始了，小哈是小哼的新同，小哼向小哈询问QQ号，小哈当然不会直接告诉小哼。
 所以小哈给了小哼一串加密过的数字，同时小哈也告诉了小哼解密规则。
 规则是这样的：首先将第1个数删除，紧接着将第2个数放到这串数的末尾，
 再将第3个数删除并将第4个数再放到这串数的末尾，再将第5个数删除……直到剩下最后一个数，将最后一个数也删除。
 按照刚才删除的顺序，把这些删除的数连在一起就是小哈的QQ啦。
 现在你来帮帮小哼吧。小哈给小哼加密过的一串数是“6 3 1 7 5 8 9 2 4”。解密后小哈的QQ号应该是“6 1 5 9 4 7 2 8 3”。

输入格式:

只有2行
第1行有一个整数n （1<=n<=100000）
第2行有n个整数为加密过的QQ号，每个整数之间用空格隔开。每个整数在1~9之间。
输出格式:

只有一行，输出解密后的QQ号。
限制:

每个测试点1秒
50%的数据1<=n<=10000
100%的数据1<=n<=100000
样例 1 :

输入:
9
6 3 1 7 5 8 9 2 4
输出:
6 1 5 9 4 7 2 8 3
 */

struct Queue {
    int* a;
    int head;
    int tail;
};

int main()
{
    int n;
    cin >> n; // 1<=n<=100000
    int* a = new int[2*n];
    Queue q = {a, 0, n - 1};
    for (int i = 0; i < n; i++) {
        cin >> q.a[i]; // 每个整数1~9
    }
    /**
     * 规则是这样的：首先将第1个数删除，紧接着将第2个数放到这串数的末尾，
 再将第3个数删除并将第4个数再放到这串数的末尾，再将第5个数删除……直到剩下最后一个数，将最后一个数也删除。
 按照刚才删除的顺序，把这些删除的数连在一起就是小哈的QQ啦。
     */
    // 好像是个堆栈问题， 删除的数就是头部的数， 移动的数就是压入的数
    while(q.head <= q.tail) {
        cout << a[q.head] << " ";
        q.head++;
        q.tail++;
        q.a[q.tail] = q.a[q.head];
        q.head++;
    }

    return 0;
}
