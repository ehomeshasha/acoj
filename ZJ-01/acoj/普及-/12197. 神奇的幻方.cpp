#include <iostream>
#include <math.h>
#include <algorithm>

using namespace std;

/**
幻方是一种很神奇的N*N矩阵：它由数字1,2,3,……,N*N构成，且每行、每列及两条对角线上的数字之和都相同。
当N为奇数时，我们可以通过以下方法构建一个幻方：
首先将1写在第一行的中间。
之后，按如下方式从小到大依次填写每个数K(K=2,3,…,N*N)：
1.若(K−1)在第一行但不在最后一列，则将K填在最后一行，(K−1)所在列的右一列；
2.若(K−1)在最后一列但不在第一行，则将K填在第一列，(K−1)所在行的上一行；
3.若(K−1)在第一行最后一列，则将K填在(K−1)的正下方；
4.若(K−1)既不在第一行，也不在最后一列，如果(K−1)的右上方还未填数，则将K填在(K−1)的右上方，否则将K填在(K−1)的正下方。

现给定N请按上述方法构造N*N的幻方。

输入格式:

输入文件只有一行，包含一个正整数 N ，即幻方的大小。
输出格式:

输出文件包含 N 行 ，每行 N 个整数，即按上述方法构造出的 N*N 的幻方，相邻两个整数之间用单空格隔开。
限制:

对于 100% 的数据，1≤N≤39 且 N 为奇数。
样例 1 :

输入:
3
输出:
8 1 6
3 5 7
4 9 2
 */

int main()
{
    // 递推算法
    int N, a[40][40] = {0}, i, j;
    cin >> N;
    // 第一个数
    i=1;
    j=(N+1)/2;
    a[i][j]=1;
    for (int K=2;K<=N*N;K++) {
        if (i==1&&j!=N) {
            i=N;
            j++;
        } else if (i!=1&&j==N) {
            i--;
            j=1;
        } else if(i==1&&j==N) {
            i++;
        } else {
            int tmpi = i-1;
            int tmpj = j+1;
            if (!a[tmpi][tmpj]) {
                i--;
                j++;
            } else {
                i++;
            }
        }

        a[i][j]=K;
    }

    for (int m=1; m<=N; m++) {
        for (int n=1; n<=N; n++) {
            cout << a[m][n] << " ";
        }
        cout << endl;
    }

    return 0;
}
