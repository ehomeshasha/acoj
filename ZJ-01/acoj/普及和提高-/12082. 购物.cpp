#include <bits/stdc++.h>


using namespace std;

/**
你就要去购物了，现在你手上有N种不同面值的银币，每种银币有无限多个。为了方便购物，你希望带尽量少的银币，但要组合出1到X之间的任意值。
输入格式:
第一行两个数X、N，以下N各数，表示每种硬币的面值。
输出格式:
最少需要携带的银币个数，如果无解输出-1。
限制:
30% N<=3 X<=20
100% N<=10 X<=1000
样例 1 :
输入:
20 4
1 2 5 10
输出:
5
 */


/**
 * 思路
 *
 * 要求的面值i（1-X） 银币数 sum求和
 * 1  1  1
 * 2  2  3
 * 3 不选 3 // 3==3, sum>=i
 * 4  2  5
 * 5 不选 5 // 5==5, sum>=i
 * 6  5  10
 * 7 不选 10
 * 8 不选 10  6~10都是属于sum>=i, 因为i==10
 * 9 不选 10
 * 10 不选 10
 * 11  10  20
 * 12 不选 20
 * 13 不选 20
 * 14 不选 20
 * 15 不选 20
 * 16 不选 20
 * 17 不选 20
 * 18 不选 20
 * 19 不选 20
 * 20 不选 20
 *
 * 总结规律
 * 1. sum>=i, 不选
 * 2. 优先选大的， 选择的银币面额<=i
 * 3. 每次只选一个，break
 */
int main()
{
    int X,N,yb[10],sum=0,cnt=0;
    cin >> X >> N;
    for (int i=0;i<N;i++) {
        cin >> yb[i];
    }
    sort(yb,yb+N);
    if (yb[0]!=1) {
        cout << -1;
        return 0;
    }
    for (int i=1;i<=X;i++) {
        if (sum>=i) continue;
        for (int j=N-1;j>=0;j--) {
            if (yb[j]<=i) {
                cnt++;
                sum+=yb[j];
                break;
            }
        }
    }
    cout << cnt;
    return 0;
}
